'use client';

import { useState } from 'react';
import { Family, GenerationMode, NormalizedCompound, BuildRow, AlkanePoint } from '@/lib/types';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { Download, AlertCircle, CheckCircle2, FileText, Info, FileDown } from 'lucide-react';
import { ResultsTable } from '@/components/features/ResultsTable';
import { Separator } from '@/components/ui/separator';
import { Switch } from '@/components/ui/switch';
import { Input } from '@/components/ui/input';

type Step = 'input' | 'path' | 'configure';

export default function Generator() {
  const [family, setFamily] = useState<Family>('Pesticides');
  const [step, setStep] = useState<Step>('input');
  const [completedSteps, setCompletedSteps] = useState<Step[]>([]);
  const [mode, setMode] = useState<GenerationMode>('withGC');
  const [methodId, setMethodId] = useState('CF40-LOCKABLE');
  const [normalized, setNormalized] = useState<NormalizedCompound[]>([]);
  const [unmatched, setUnmatched] = useState<string[]>([]);
  const [rows, setRows] = useState<BuildRow[]>([]);
  const [calibrated, setCalibrated] = useState(false);
  const [loading, setLoading] = useState(false);
  const [inputText, setInputText] = useState('');
  const [alkaneText, setAlkaneText] = useState('');
  const [expandCE, setExpandCE] = useState(true);
  const [ceDelta, setCeDelta] = useState(4);
  const [showGapReport, setShowGapReport] = useState(false);
  const [selectedMethodForExport, setSelectedMethodForExport] = useState<string>('');

  function markStepCompleted(stepToMark: Step) {
    if (!completedSteps.includes(stepToMark)) {
      setCompletedSteps([...completedSteps, stepToMark]);
    }
  }

  function goToStep(nextStep: Step) {
    setStep(nextStep);
  }

  const handleInputSubmit = async (queries: string[]) => {
    setLoading(true);
    try {
      const filtered = queries.filter(q => q.trim().length > 0);

      if (filtered.length === 0) {
        alert('Please enter at least one compound name or CAS number');
        setLoading(false);
        return;
      }

      const res = await fetch('/api/normalize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ family, query: filtered })
      });

      if (!res.ok) {
        throw new Error(`API error: ${res.status}`);
      }

      const data = await res.json();
      setNormalized(data.results || []);
      setUnmatched(data.unmatched || []);

      if ((data.results || []).length === 0 && (data.unmatched || []).length === 0) {
        alert('No matching compounds found, please check your input');
      } else {
        markStepCompleted('input');
        goToStep('path');
      }
    } catch (error) {
      console.error('Normalization error:', error);
      alert('Error processing input, please try again');
    } finally {
      setLoading(false);
    }
  };

  const handleBuild = async () => {
    setLoading(true);
    try {
      const compoundIds = normalized.map(n => n.compoundId);
      const res = await fetch('/api/build', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          family,
          mode,
          methodId: mode === 'withGC' ? methodId : undefined,
          compoundIds,
          expandCE,
          delta: ceDelta
        })
      });

      const data = await res.json();
      const builtRows = data.rows || [];

      const enriched = builtRows.map((row: BuildRow) => {
        const compound = normalized.find(n => n.compoundId === row.compoundId);
        return {
          ...row,
          compound: compound?.name || '',
          cas: compound?.cas || ''
        };
      });

      setRows(enriched);
    } catch (error) {
      console.error('Build error:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCalibrate = async () => {
    setLoading(true);
    try {
      const lines = alkaneText
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#') && !l.toLowerCase().startsWith('alkane'));

      const alkanes: AlkanePoint[] = [];
      const parseErrors: string[] = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const parts = line.split(/[,\t\s]+/).filter(p => p.trim());

        if (parts.length >= 2) {
          const name = parts[0].toUpperCase().trim();
          const rtStr = parts[1].replace(/,/g, '.');
          const rt = parseFloat(rtStr);

          if (!isNaN(rt) && rt > 0) {
            alkanes.push({ name, rt });
          } else {
            parseErrors.push(`Line ${i + 1}: Invalid RT value "${parts[1]}"`);
          }
        } else {
          parseErrors.push(`Line ${i + 1}: Invalid format "${line}"`);
        }
      }

      if (alkanes.length < 5) {
        const errorMsg = `Successfully parsed only ${alkanes.length} alkanes, need at least 5.\n\nParse errors:\n${parseErrors.slice(0, 5).join('\n')}${parseErrors.length > 5 ? '\n...' : ''}`;
        alert(errorMsg);
        setLoading(false);
        return;
      }

      const riRows = rows
        .filter((r, idx, self) => self.findIndex(x => x.compoundId === r.compoundId) === idx)
        .map(r => ({
          compoundId: r.compoundId,
          RI_ref: r.RI_ref || 0,
          RT_window: r.RT_window
        }))
        .filter(r => r.RI_ref > 0);

      const res = await fetch('/api/calibrate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          family,
          methodId,
          alkanes,
          rows: riRows
        })
      });

      if (!res.ok) {
        const errorData = await res.json();
        alert(`Calibration failed: ${errorData.error || 'Unknown error'}`);
        setLoading(false);
        return;
      }

      const data = await res.json();

      if (!data.mapped || !Array.isArray(data.mapped)) {
        alert('Calibration failed: Server returned invalid data format');
        setLoading(false);
        return;
      }

      const mappedMap = new Map(data.mapped.map((m: any) => [m.compoundId, m]));

      const updated = rows.map(row => {
        const mapped = mappedMap.get(row.compoundId);
        if (mapped && typeof mapped === 'object' && 'RT_pred' in mapped && 'RT_window' in mapped) {
          const rtWindow = (mapped as any).RT_window;
          return {
            ...row,
            RT_pred: (mapped as any).RT_pred,
            RT_window: `Â±${Math.abs(rtWindow[0]).toFixed(2)}`
          };
        }
        return row;
      });

      setRows(updated);
      setCalibrated(true);
      alert(`RI calibration successful! Updated RT prediction values for ${data.mapped.length} compounds.`);
    } catch (error) {
      console.error('Calibration error:', error);
      alert(`Calibration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  const handleExport = async (format: 'generic' | 'masshunter' | 'both') => {
    try {
      const res = await fetch('/api/export', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          rows,
          format,
          unmatched
        })
      });

      const data = await res.json();

      if (format === 'generic' || format === 'both') {
        downloadCSV(data.generic, 'method_generic.csv');
      }

      if (format === 'masshunter' || format === 'both') {
        downloadCSV(data.masshunter, 'method_masshunter.csv');
      }

      if (data.gap && unmatched.length > 0) {
        downloadCSV(data.gap, 'gap_report.csv');
      }

      markStepCompleted('configure');
    } catch (error) {
      console.error('Export error:', error);
    }
  };

  const downloadCSV = (content: string, filename: string) => {
    const BOM = '\uFEFF';
    const blob = new Blob([BOM + content], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleExportMethod = async () => {
    if (!selectedMethodForExport) {
      alert('Please select a GC method to export');
      return;
    }

    try {
      const res = await fetch('/api/export-method', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          family,
          methodId: selectedMethodForExport
        })
      });

      const data = await res.json();

      if (data.csv) {
        downloadCSV(data.csv, `GC_Method_${selectedMethodForExport}.csv`);
      }
    } catch (error) {
      console.error('Export method error:', error);
      alert('GC method export failed');
    }
  };

  const handleDownloadTemplate = () => {
    const templateContent = `Compound Name or CAS Number
Chlorpyrifos
1912-24-9
Malathion
Fenitrothion
Parathion
56-38-2`;

    downloadCSV(templateContent, 'compound_input_template.csv');
  };

  const handleDownloadAlkaneTemplate = () => {
    const alkaneTemplateContent = `Alkane,RT(min)
C8,2.466
C9,3.014
C10,3.513
C11,3.970
C12,4.400
C13,4.810
C14,5.210
C15,5.600
C16,5.980
C17,6.350
C18,6.720
C19,7.080
C20,7.430
C21,7.770
C22,8.110
C23,8.440
C24,8.770
C25,9.090
C26,9.410
C27,9.720
C28,10.030
C29,10.330
C30,10.630
C31,10.930
C32,11.220
C33,11.510
C34,11.790
C35,12.070`;

    downloadCSV(alkaneTemplateContent, 'alkane_calibration_template.csv');
  };